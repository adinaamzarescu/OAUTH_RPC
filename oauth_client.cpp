/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "utils.h"

map<string, string> userData;
map<string, string> userRefresh;
map<string, bool> automatedRefresh;

void authz_and_access(CLIENT *clnt, string user_identifier, bool refresh_token)
{
    char **result_1;
    char *request_authorization_1_arg;
    struct token_details *result_2;
    struct token_refresh_request request_access_token_1_arg;
    char **result_4;
    char *approve_request_token_1_arg;

    ALLOCATE_STRING(request_authorization_1_arg, MEMORY_SIZE);
    strcpy(request_authorization_1_arg, user_identifier.c_str());
    result_1 = request_authorization_1(&request_authorization_1_arg, clnt);

    if (result_1 == (char **)NULL)
    {
        clnt_perror(clnt, STR_CALL_FAILED);
    }

    ALLOCATE_STRING(approve_request_token_1_arg, MEMORY_SIZE);
    strcpy(approve_request_token_1_arg, *result_1);
    result_4 = approve_request_token_1(&approve_request_token_1_arg, clnt);
    if (result_4 == (char **)NULL)
    {
        clnt_perror(clnt, STR_CALL_FAILED);
    }

    ALLOCATE_STRING(request_access_token_1_arg.user_identifier, MEMORY_SIZE);
    strcpy(request_access_token_1_arg.user_identifier, user_identifier.c_str());
    ALLOCATE_STRING(request_access_token_1_arg.request_token, MEMORY_SIZE);
    strcpy(request_access_token_1_arg.request_token, *result_1);
    request_access_token_1_arg.refresh_token = refresh_token;
    request_access_token_1_arg.initiate_refresh = false;

    result_2 = request_access_token_1(&request_access_token_1_arg, clnt);
    if (result_2 == (struct token_details *)NULL)
    {
        clnt_perror(clnt, STR_CALL_FAILED);
    }

    if (strcmp(*result_1, STR_USER_NOT_FOUND) == 0)
    {
        PRINT_STRING(result_1);
    }
    else
    {
        string accT((*result_2).access_token);
        userData[user_identifier] = accT;
        if (refresh_token == true)
        {
            string refrT((*result_2).refresh_token);
            userRefresh[user_identifier] = refrT;
        }
        if (strcmp(result_2->token_error_message, STR_REQUEST_DENIED) == 0)
        {
            PRINT_STRING(&(result_2->token_error_message));
        }
        else
        {
			PRINT_COMPLETE_TOKEN_DETAILS(result_1, result_2->access_token, result_2->refresh_token, refresh_token);
        }
    }
    automatedRefresh[user_identifier] = refresh_token;

    FREE_MEMORY(request_authorization_1_arg);
    FREE_MEMORY(approve_request_token_1_arg);
    FREE_MEMORY(request_access_token_1_arg.user_identifier);
    FREE_MEMORY(request_access_token_1_arg.request_token);
    FREE_MEMORY(*result_1);
    FREE_MEMORY(result_2->access_token);
    FREE_MEMORY(result_2->refresh_token);
    FREE_MEMORY(result_2->token_error_message);
    FREE_MEMORY(*result_4);
}

void assignTokenData(int index, const string& token, string& user_identifier, string& type_of_operation, string& targeted_resource) {
    string* dataPointers[3] = {&user_identifier, &type_of_operation, &targeted_resource};
    *dataPointers[index % 3] = token;
}

void oauth_1(char *host, char *clientFile)
{
    CLIENT *clnt;
    char **result_1;
    char *request_authorization_1_arg;
    struct token_details *result_2;
    struct token_refresh_request request_access_token_1_arg;
    char **result_3;
    struct operation_details validate_delegated_action_1_arg;
    char **result_4;
    char *approve_request_token_1_arg;
    int *result_5;
    char *check_valability_1_arg;

#ifndef DEBUG
    clnt = clnt_create(host, OAUTH, OAUTHVERS, STR_UDP);
    if (clnt == NULL)
    {
        clnt_pcreateerror(host);
        exit(1);
    }
#endif /* DEBUG */
    ifstream inputFile(clientFile);

    if (!inputFile.is_open())
    {
        cout << STR_ERROR_OPENING_FILE;
    }

    string line, token, user_identifier, type_of_operation, targeted_resource;
    while (getline(inputFile, line, CHAR_NEWLINE))
    {
        bool expired = false;
		istringstream lineStream(line);
		int i = 3;
		while (getline(lineStream, token, CHAR_COMMA)) {
			assignTokenData(i, token, user_identifier, type_of_operation, targeted_resource);
			i++;
		}
		if (type_of_operation == STR_REQUEST_OPERATION)
		{
			int resource_value = std::stoi(targeted_resource);
			bool use_refresh_token = (resource_value == 1);
			authz_and_access(clnt, user_identifier, use_refresh_token);
		}
        ALLOCATE_STRING(check_valability_1_arg, MEMORY_SIZE);
        strcpy(check_valability_1_arg, user_identifier.c_str());
        result_5 = check_token_validity_1(&check_valability_1_arg, clnt);
        if (result_5 == (int *)NULL)
        {
            clnt_perror(clnt, STR_CALL_FAILED);
        }
        if (*result_5 == 0 && automatedRefresh[user_identifier] == true)
        {
            ALLOCATE_STRING(request_access_token_1_arg.user_identifier, MEMORY_SIZE);
            strcpy(request_access_token_1_arg.user_identifier, user_identifier.c_str());
            ALLOCATE_STRING(request_access_token_1_arg.request_token, MEMORY_SIZE);
            strcpy(request_access_token_1_arg.request_token, userRefresh[user_identifier].c_str());
            request_access_token_1_arg.refresh_token = true;
            request_access_token_1_arg.initiate_refresh = true;

            result_2 = request_access_token_1(&request_access_token_1_arg, clnt);
            if (result_2 == (struct token_details *)NULL)
            {
                clnt_perror(clnt, STR_CALL_FAILED);
            }
            string accT((*result_2).access_token);
            userData[user_identifier] = accT;
            string refrT((*result_2).refresh_token);
            userRefresh[user_identifier] = refrT;

            FREE_MEMORY(request_access_token_1_arg.user_identifier);
            FREE_MEMORY(request_access_token_1_arg.request_token);
            FREE_MEMORY(result_2->access_token);
            FREE_MEMORY(result_2->refresh_token);
            FREE_MEMORY(result_2->token_error_message);
        }

        if (type_of_operation != STR_REQUEST_OPERATION)
        {
            ALLOCATE_STRING(validate_delegated_action_1_arg.access_token, MEMORY_SIZE);
            ALLOCATE_STRING(validate_delegated_action_1_arg.type_of_operation, MEMORY_SIZE);
            ALLOCATE_STRING(validate_delegated_action_1_arg.targeted_resource, MEMORY_SIZE);
            strcpy(validate_delegated_action_1_arg.access_token, userData[user_identifier].c_str());
            strcpy(validate_delegated_action_1_arg.targeted_resource, targeted_resource.c_str());
            strcpy(validate_delegated_action_1_arg.type_of_operation, type_of_operation.c_str());

            result_3 = validate_delegated_action_1(&validate_delegated_action_1_arg, clnt);
            if (result_3 == (char **)NULL)
            {
                clnt_perror(clnt, STR_CALL_FAILED);
            }
            PRINT_STRING(result_3);

            FREE_MEMORY(check_valability_1_arg);
            FREE_MEMORY(validate_delegated_action_1_arg.access_token);
            FREE_MEMORY(validate_delegated_action_1_arg.type_of_operation);
            FREE_MEMORY(validate_delegated_action_1_arg.targeted_resource);
        }
    }
    inputFile.close();
#ifndef DEBUG
    clnt_destroy(clnt);
#endif /* DEBUG */
}

int main(int argc, char *argv[])
{
    char *host, *clientFile;

    if (argc < 3)
    {
        printf("usage: %s server_host client_file\n", argv[0]);
        exit(1);
    }
    ALLOCATE_STRING(host, MEMORY_SIZE);
    ALLOCATE_STRING(clientFile, MEMORY_SIZE);
    strcpy(host, argv[1]);
    strcpy(clientFile, argv[2]);

    oauth_1(host, clientFile);

    FREE_MEMORY(host);
    FREE_MEMORY(clientFile);
    exit(0);
}
