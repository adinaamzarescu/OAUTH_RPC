/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "oauth.h"
#include "token.h"
#include "utils.h"

map<string, vector<struct permissions_detail>> approvals;

char *generate_access_token(char *clientIdToken);

bool find_user(char *user_id, char **result_token) {
    for (int i = 0; i < user_list.size(); i++) {
        if (strcmp(user_list[i].user_identifier, user_id) == 0) {
            strcpy(*result_token, generate_access_token(user_id));
            strcpy(user_list[i].tokens.request_token, *result_token);
            return true;
        }
    }
    return false;
}

permissions_detail initialize_permissions_detail(string targeted_resource, string granted_permissions) {
    permissions_detail rp;
    ALLOCATE_STRING(rp.targeted_resource, MEMORY_SIZE);
    ALLOCATE_STRING(rp.granted_permissions, MEMORY_SIZE);
    strcpy(rp.targeted_resource, targeted_resource.c_str());
    strcpy(rp.granted_permissions, granted_permissions.c_str());
    return rp;
}

void update_permissions_details(string result_token, string line) {
    istringstream lineStream(line);
    string token, targeted_resource, granted_permissions;
    vector<struct permissions_detail> perms;
    int i = 2;
    while (getline(lineStream, token, CHAR_COMMA)) {
        if (i % 2 == 0) targeted_resource = token;
        else {
            granted_permissions = token;
            perms.push_back(initialize_permissions_detail(targeted_resource, granted_permissions));
        }
        i++;
    }
    approvals[result_token] = perms;
}

char **request_authorization_1_svc(char **argp, struct svc_req *rqstp)
{
    static char *result;
    ALLOCATE_STRING(result, MEMORY_SIZE);

    LOG_ACTION(*argp, STR_AUTHZ);

    if (!find_user(*argp, &result)) {
        strcpy(result, STR_USER_NOT_FOUND);
        return &result;
    }

    string line;
    if (!getline(input_file_4, line, CHAR_NEWLINE)) {
        PRINT_REQUEST_TOKEN(result);
        return &result;
    }

    update_permissions_details(string(result), line);
    PRINT_REQUEST_TOKEN(result);
    return &result;
}

void initialize_token_details(struct token_details *details) {
    ALLOCATE_STRING(details->request_token, MEMORY_SIZE);
    ALLOCATE_STRING(details->access_token, MEMORY_SIZE);
    ALLOCATE_STRING(details->refresh_token, MEMORY_SIZE);
    ALLOCATE_STRING(details->token_error_message, MEMORY_SIZE);
}

struct token_details *
request_access_token_1_svc(struct token_refresh_request *argp, struct svc_req *rqstp)
{
    static struct token_details result;
    initialize_token_details(&result);

    for (int i = 0; i < user_list.size(); i++)
    {
        if (strcmp(user_list[i].user_identifier, argp->user_identifier) == 0)
        {
            if (user_list[i].is_token_validated == true)
            {
                ALLOCATE_STRING(user_list[i].tokens.access_token, MEMORY_SIZE);
                ALLOCATE_STRING(user_list[i].tokens.refresh_token, MEMORY_SIZE);

                char *access_token = NULL;
                ALLOCATE_STRING(access_token, MEMORY_SIZE);
                strcpy(access_token, generate_access_token(argp->request_token));

                char *refresh_token = NULL;
                ALLOCATE_STRING(refresh_token, MEMORY_SIZE);

                if (argp->refresh_token && user_list[i].tokens.token_validity_seconds == 0 && argp->initiate_refresh == true)
                {
                    LOG_ACTION(argp->user_identifier, STR_AUTHZ_REFRESH);
                }
                strcpy(user_list[i].tokens.access_token, access_token);
                user_list[i].tokens.token_validity_seconds = token_validity_seconds;
                result.token_validity_seconds = token_validity_seconds;

                strcpy(result.access_token, access_token);
                PRINT_ACCESS_TOKEN(result.access_token);
                if (argp->refresh_token)
                {
                    strcpy(refresh_token, generate_access_token(access_token));
                    strcpy(user_list[i].tokens.refresh_token, refresh_token);
                    strcpy(result.refresh_token, refresh_token);
                    PRINT_REFRESH_TOKEN(result.refresh_token);
                }
                FREE_MEMORY(access_token);
                FREE_MEMORY(refresh_token);
                break;
            }
            else
            {
                strcpy(result.token_error_message, STR_REQUEST_DENIED);
                break;
            }
        }
    }

    return &result;
}

char **
validate_delegated_action_1_svc(struct operation_details *argp, struct svc_req *rqstp)
{
	static char *result;
	ALLOCATE_STRING(result, MEMORY_SIZE);
	strcpy(result, STR_NULL_TERMINATOR);
	bool found = false;
	int token_validity_seconds = 0;
	char access_token[MEMORY_SIZE];

	for (int i = 0; i < user_list.size(); i++)
	{
		bool ok = false;
		if (strcmp(user_list[i].tokens.access_token, argp->access_token) == 0
		 	&& strlen(argp->access_token) != 0)
		{
			strcpy(access_token, argp->access_token);
			found = true;
			if (user_list[i].is_token_validated == true)
			{
				if (user_list[i].tokens.token_validity_seconds == 0)
				{
                    LOG_DENY(argp->type_of_operation, argp->targeted_resource, STR_EMPTY, user_list[i].tokens.token_validity_seconds);
                    strcpy(result, STR_TOKEN_EXPIRED);
                    break;
				}
				else
				{
					string res(argp->targeted_resource);
					vector<string>::iterator it;
					it = find(resources.begin(), resources.end(), res);
					if (it != resources.end())
					{
						for (int j = 0; j < approvals[user_list[i].tokens.request_token].size(); j++)
						{
							if (strcmp(approvals[user_list[i].tokens.request_token][j].targeted_resource, 
									argp->targeted_resource) == 0)
							{
								string perms(approvals[user_list[i].tokens.request_token][j].granted_permissions);
								string op(argp->type_of_operation);
								if (perms.find(op.at(strcmp(argp->type_of_operation, STR_EXECUTE) == 0 
										? 1 : 0)) != string::npos)
								{
                                    user_list[i].tokens.token_validity_seconds--;
                                    token_validity_seconds = user_list[i].tokens.token_validity_seconds;
                                    LOG_PERMIT(argp->type_of_operation, argp->targeted_resource, access_token, user_list[i].tokens.token_validity_seconds);
                                    strcpy(result, STR_PERMISSION_GRANTED);
                                    ok = true;
                                    break;
								}
								else
								{
                                    user_list[i].tokens.token_validity_seconds--;
                                    token_validity_seconds = user_list[i].tokens.token_validity_seconds;
                                    LOG_DENY(argp->type_of_operation, argp->targeted_resource, access_token, user_list[i].tokens.token_validity_seconds);
                                    strcpy(result, STR_OPERATION_NOT_PERMITTED);
                                    ok = true;
                                    break;
								}
							}
						}
						if (ok)
						{
							break;
						}
					}
					else
					{
                        user_list[i].tokens.token_validity_seconds--;
                        token_validity_seconds = user_list[i].tokens.token_validity_seconds;
                        LOG_DENY(argp->type_of_operation, argp->targeted_resource, access_token, user_list[i].tokens.token_validity_seconds);
                        strcpy(result, STR_RESOURCE_NOT_FOUND);
                        break;
					}
				}
			}
		}
	}
	if (found == false)
	{
        LOG_DENY(argp->type_of_operation, argp->targeted_resource, STR_EMPTY, token_validity_seconds);
        strcpy(result, STR_PERMISSION_DENIED);
	}
	else
	{
		if (strlen(result) == 0)
		{
			for (int i = 0; i < user_list.size(); i++)
			{
				if (strcmp(user_list[i].tokens.access_token, argp->access_token) == 0)
				{
					user_list[i].tokens.token_validity_seconds--;
					token_validity_seconds = user_list[i].tokens.token_validity_seconds;
				}
			}
            LOG_DENY(argp->type_of_operation, argp->targeted_resource, access_token, token_validity_seconds);
            strcpy(result, STR_OPERATION_NOT_PERMITTED);
		}
	}

	return &result;
}

char **
approve_request_token_1_svc(char **argp, struct svc_req *rqstp)
{
	static char *result;
	ALLOCATE_STRING(result, MEMORY_SIZE);
	bool found = false;

	for (auto entry : approvals)
	{
        const string& key = entry.first;
        const auto& value = entry.second;
        if (*argp == key && strcmp(value[0].targeted_resource, STR_WILDCARD) == 0 &&
            strcmp(value[0].granted_permissions, STR_DASH) == 0)
        {
            auto it = std::find_if(user_list.begin(), user_list.end(),
                                   [&](const user_credentials& user) {
                                       return strcmp(user.tokens.request_token, *argp) == 0;
                                   });
            if (it != user_list.end())
            {
                it->is_token_validated = false;
                found = true;
                break;
            }
        }
	}
    if (!found)
    {
        auto it = std::find_if(user_list.begin(), user_list.end(),
                               [&](const user_credentials& user) {
                                   return strcmp(user.tokens.request_token, *argp) == 0;
                               });
        if (it != user_list.end())
        {
            it->is_token_validated = true;
        }
    }
	INITIALIZE_STRING(result, *argp);

	return &result;
}

int *check_token_validity_1_svc(char **argp, struct svc_req *rqstp)
{
    static thread_local int result = -1;

    result = -1;
    for (const auto& user : user_list)
    {
        if (strcmp(user.user_identifier, *argp) == 0)
        {
            result = user.tokens.token_validity_seconds;
            break;
        }
    }

    return &result;
}
